# セクション2: テスト設計の論点と問題ケース

このセクションでは、テストの設計を「設計活動」として捉え直し、問題となるケースとその理由、回避のための設計ルール、不変条件、最小実装例を示す。

## 問題の言い換え（何を議論するか）
- 「モックをしすぎるとテストの意味がなくなる」状況とは何か？
- 「ネットワーク越しのテスト」をいつ実施し、いつ避けるべきか？
- 設計上の境界（ポート/アダプタ、ドメイン/インフラ）がテストにどのように反映されるか？

## 用語定義（ユビキタス言語）
- SUT: System Under Test。テスト対象のクラス/関数/モジュール。
- ポート/アダプタ: 外部I/Oを抽象（ポート）と具象（アダプタ）に分離する設計。
- テストダブル: ダミー/スタブ/フェイク/スパイ/モックの総称。
- シーム: 非決定性や外部I/Oを注入・置換できる結合点（時間・乱数・UUID・HTTP/DB 等）。
- 契約テスト: 境界越しのスキーマ・プロトコル・DTO契約の整合性を確認するテスト。

## テストの問題となるケースと理由
1) モック過多（Over‑Mocking）
   - 症状: ほぼすべての依存をモックし、SUTの公開結果ではなく「呼び順/回数」を検証。
   - 理由: 実装詳細に密結合→リファクタで大量破壊。統合不整合（シリアライズ、タイムアウト、リトライ）が検出不能。

2) ネットワーク越しテストの多用
   - 症状: 外部API/DBに実際に接続するE2Eが多数。
   - 理由: 遅い・不安定・高コスト・非決定（レート制限/時刻/データ揺らぎ）。失敗の局在化が難しい。

3) 実装詳細アサーション
   - 症状: 内部メソッドやプライベート状態、呼び出し順序の固定化。
   - 理由: 設計変更に弱く、振る舞い（出力・状態遷移・イベント）を検証できない。

4) 非決定性の直結（シーム不在）
   - 症状: `Date.now()`/乱数/UUID/並列性/現在時刻を直参照。
   - 理由: テストが再現不能・断続的な失敗（flake）化。注入可能な設計で決定性を確保すべき。

5) 環境/順序依存
   - 症状: テスト間でデータ共有、実行順序が変わると壊れる、ローカル設定に依存。
   - 理由: テストの独立性と並列実行性を損ねる。

6) 契約ずれ（スキーマ・プロトコル）
   - 症状: API/イベント/DBの契約が進化してもテストに反映されない。
   - 理由: 統合時に破綻。契約テストで早期検出が必要。

7) ピラミッドの逆転
   - 症状: E2E偏重で単体が薄い、または単体偏重で統合が無い。
   - 理由: 検出力とコストのバランスが崩れ、修正が遅延。

## 設計ルール/境界（テストに落とす設計判断）
- 依存の向き: 上位ポリシー（ドメイン）→ 下位詳細（インフラ）。ドメインはポートにのみ依存。
- 公開契約で検証: 入力→出力/状態/ドメインイベントを観測。内部詳細の固定化を避ける。
- シーム設計: 時間/乱数/UUID/外部I/Oを注入可能に（インターフェース/関数引数）し、フェイクで決定性を確保。
- 契約テスト: 境界（HTTP/メッセージ/DB）ではスキーマ契約を明文化し、差分を検出。
- ピラミッド維持: 単体（多）/統合（中）/E2E（少）。E2Eは重要経路のスモークに限定。

## 不変条件/例外
- 再現性: 同じ入力・環境で同じ結果が得られる（非決定性はシームで固定）。
- 独立性: テストは順序や他テストの副作用に依存しない。
- 観測可能性: 公開APIの結果・状態・イベントのみを根拠に合否判定。
- 局在化: 失敗は責務境界内で原因特定できる。

## 最小コード例（ポート/シーム/公開契約）
```ts
// ポート設計: 外部I/Oと時間を抽象化（テストでフェイク注入）
export interface Http {
  get(url: string): Promise<{ status: number; body: unknown }>;
}
export interface Clock { now(): Date; }

// SUT: 公開契約は入力→出力（結果 + 事実）。内部の呼び順は検証しない。
export class UserFetcher {
  constructor(private readonly http: Http, private readonly clock: Clock) {}
  async fetchName(id: string) {
    const res = await this.http.get(`/users/${id}`);
    if (res.status !== 200) throw new Error("not found");
    const name = (res.body as any).name;
    return { name, at: this.clock.now() };
  }
}
```
設計意図:
- 「ネットワーク」「現在時刻」をポート化して注入可能に→テストでフェイクを使い高速・決定化。
- 検証は公開結果（name, at）に限定→実装詳細からの脱却。

## BDDミニシナリオ（例）
```
機能: ユーザー名を取得する
  シナリオ: 正常にユーザーが見つかる
    前提 /users/42 は { name: "Taro" } を返す
    かつ 現在時刻は 2025-01-01T00:00:00Z
    もし id=42 で fetchName する
    ならば 結果.name は "Taro"
    かつ 結果.at は 2025-01-01T00:00:00Z
```

## チェックリスト
モック過多チェック:
- [ ] 公開結果（出力/状態/イベント）で合否を判定しているか？
- [ ] 呼び出し回数/順序への過度な依存をしていないか？
- [ ] フェイクで再現できるところをモックで固定化していないか？

ネットワークE2E選定基準:
- [ ] 契約テストや統合テストで代替できない重要経路か？
- [ ] 固定環境・固定データ・リトライ/タイムアウト戦略があるか？
- [ ] スモークレベルに留め、本数を絞っているか？

シーム一覧（最低限用意）:
- [ ] 時間（Clock）  [ ] 乱数  [ ] UUID  [ ] HTTP/メッセージ  [ ] DB I/O

## 次の一歩（実験タスク）
- 「時間」「乱数」「外部API」それぞれのシームを1つずつ設計し、フェイクで単体テストを作成。
- 小さな集約（例: 口座）の不変条件テーブルを作り、正常/境界/異常ケースをテスト化。
- 境界（HTTP/イベント）の契約テスト雛形を追加し、スキーマ差分を検出できるようにする。
